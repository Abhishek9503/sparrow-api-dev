import { Injectable, OnModuleInit, Inject } from "@nestjs/common";
import { Collections } from "@src/modules/common/enum/database.collection.enum";
import { Collection } from "@src/modules/common/models/collection.model";
import { Testflow } from "@src/modules/common/models/testflow.model";
import { Db } from "mongodb";

const defaultState = {
  requestBodyLanguage: "Text",
  requestBodyNavigation: "None",
  requestAuthNavigation: "No Auth",
  requestNavigation: "Request Body",
  responseNavigation: "Response",
  responseBodyLanguage: "Text",
  responseBodyFormatter: "Pretty",
  requestExtensionNavigation: "",
  requestLeftSplitterWidthPercentage: 50,
  requestRightSplitterWidthPercentage: 50,
  isExposeEditDescription: true,
  isSendRequestInProgress: false,
  isSaveDescriptionInProgress: false,
  isSaveRequestInProgress: false,
  isParameterBulkEditActive: false,
  isHeaderBulkEditActive: false,
  isChatbotActive: false,
  isChatbotSuggestionsActive: true,
  isChatbotGeneratingResponse: false,
  isDocGenerating: false,
  isDocAlreadyGenerated: false,
};

const defaultAutoGeneratedHeaders = [
  { key: "Accept", value: "*/*", checked: true },
  { key: "Connection", value: "keep-alive", checked: true },
  {
    key: "User-Agent",
    value:
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
    checked: true,
  },
  { key: "Accept-Encoding", value: "gzip, br", checked: true },
];

@Injectable()
export class UpdateTestFlowModelMigration implements OnModuleInit {
  constructor(@Inject("DATABASE_CONNECTION") private readonly db: Db) {}

  async onModuleInit(): Promise<void> {
    try {
      console.log("Update test flow model migration start.");
      const testFlowCollection = this.db.collection<Testflow>(
        Collections.TESTFLOW,
      );
      const collectionCollection = this.db.collection<Collection>(
        Collections.COLLECTION,
      );

      const testflows = await testFlowCollection.find().toArray();
      const collections = await collectionCollection.find().toArray();

      for (const flow of testflows) {
        const updatedNodes = await this.updateNodes(
          flow.nodes || [],
          collections,
          flow.workspaceId,
        );
        flow.nodes = updatedNodes;
        await testFlowCollection.updateOne(
          { _id: flow._id },
          { $set: { nodes: updatedNodes } },
        );
      }
      console.log("Update test flow model migration end.");
    } catch (error) {
      console.error("Error during update testflow model migration:", error);
    }
  }

  private async updateNodes(
    nodes: any[],
    collections: any[],
    workspaceId: string,
  ) {
    return nodes.map((node) => {
      if (node?.id === "1") {
        return {
          ...node,
          blockName: "startBlock",
          data: {
            collectionId: "",
            folderId: "",
            isDeleted: false,
            method: "",
            name: "",
            requestData: null,
            requestId: "",
            workspaceId,
          },
        };
      } else {
        const { collectionId, requestId, folderId, method, name } =
          node?.data || {};
        let requestData = this.findRequestData(
          collections,
          collectionId,
          folderId,
          requestId,
        );

        if (requestData) {
          requestData = {
            ...requestData,
            state: defaultState,
            autoGeneratedHeaders: defaultAutoGeneratedHeaders,
          };
        }

        return {
          ...node,
          blockName: `block ${node.id - 1}`,
          data: {
            collectionId,
            folderId,
            requestId,
            workspaceId,
            isDeleted: false,
            method,
            name,
            requestData,
          },
        };
      }
    });
  }

  private findRequestData(
    collections: any[],
    collectionId: string,
    folderId: string,
    requestId: string,
  ) {
    const collection = collections.find(
      (col) => col._id?.toString() === collectionId,
    );
    if (!collection?.items) return null;

    for (const folder of collection.items) {
      if (folderId && folder.id === folderId) {
        return (
          folder.items?.find((item: any) => item.id === requestId)?.request ||
          null
        );
      }
      if (!folderId && folder.id === requestId) {
        return folder?.request || null;
      }
    }
    return null;
  }
}
